stages:
  - lint
  - security
  - test
  - build
  - deploy

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  NODE_VERSION: "24"

# Cache for npm dependencies
.npm_cache: &npm_cache
  cache:
    key:
      files:
        - backend/package-lock.json
        - frontend/package-lock.json
    paths:
      - backend/node_modules
      - frontend/node_modules

# Backend lint job
lint-backend:
  stage: lint
  image: node:${NODE_VERSION}
  <<: *npm_cache
  script:
    - cd backend
    - npm ci
    - npm run lint || true
  only:
    - merge_requests
    - main
    - develop

# Frontend lint job
lint-frontend:
  stage: lint
  image: node:${NODE_VERSION}
  <<: *npm_cache
  script:
    - cd frontend
    - npm ci
    - npm run lint
  only:
    - merge_requests
    - main
    - develop

# Security scan job
security-scan:
  stage: security
  image: node:${NODE_VERSION}
  <<: *npm_cache
  script:
    - cd backend && npm ci
    - cd ../frontend && npm ci
    - chmod +x scripts/security-scan.sh
    - ./scripts/security-scan.sh
    - cd backend && npm audit --audit-level=moderate || true
    - cd ../frontend && npm audit --audit-level=moderate || true
  allow_failure: true
  only:
    - merge_requests
    - main
    - develop

# Semgrep security scan
semgrep-scan:
  stage: security
  image: returntocorp/semgrep:latest
  script:
    - semgrep --config=auto --json --output=semgrep-results.json . || true
  artifacts:
    reports:
      sast: semgrep-results.json
    expire_in: 1 week
  allow_failure: true
  only:
    - merge_requests
    - main
    - develop

# Snyk security scan
snyk-scan:
  stage: security
  image: node:${NODE_VERSION}
  before_script:
    - npm install -g snyk
  script:
    - |
      if [ -n "$SNYK_TOKEN" ]; then
        snyk auth $SNYK_TOKEN || true
        cd backend && snyk test --severity-threshold=high --all-projects || true
        cd ../frontend && snyk test --severity-threshold=high --all-projects || true
      else
        echo "SNYK_TOKEN not set, skipping Snyk scan"
      fi
  allow_failure: true
  only:
    - merge_requests
    - main
    - develop

# Backend tests
test-backend:
  stage: test
  image: node:${NODE_VERSION}
  <<: *npm_cache
  script:
    - cd backend
    - npm ci
    - npm test -- --coverage
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: backend/coverage/cobertura-coverage.xml
    paths:
      - backend/coverage
    expire_in: 1 week
  only:
    - merge_requests
    - main
    - develop

# Frontend tests
test-frontend:
  stage: test
  image: node:${NODE_VERSION}
  <<: *npm_cache
  script:
    - cd frontend
    - npm ci
    - npm test -- --coverage --watchAll=false
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: frontend/coverage/cobertura-coverage.xml
    paths:
      - frontend/coverage
    expire_in: 1 week
  only:
    - merge_requests
    - main
    - develop

# Build backend Docker image
build-backend:
  stage: build
  image: docker:24-dind
  services:
    - docker:24-dind
  variables:
    DOCKER_BUILDKIT: 1
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - |
      docker build \
        --cache-from $CI_REGISTRY_IMAGE/backend:latest \
        --tag $CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA \
        --tag $CI_REGISTRY_IMAGE/backend:latest \
        --file infra/docker/Dockerfile.backend \
        backend/
    - docker push $CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA
    - docker push $CI_REGISTRY_IMAGE/backend:latest
  only:
    - main
    - develop
    - tags

# Build frontend Docker image
build-frontend:
  stage: build
  image: docker:24-dind
  services:
    - docker:24-dind
  variables:
    DOCKER_BUILDKIT: 1
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - |
      docker build \
        --cache-from $CI_REGISTRY_IMAGE/frontend:latest \
        --tag $CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA \
        --tag $CI_REGISTRY_IMAGE/frontend:latest \
        --file infra/docker/Dockerfile.frontend \
        frontend/
    - docker push $CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA
    - docker push $CI_REGISTRY_IMAGE/frontend:latest
  only:
    - main
    - develop
    - tags

# Trivy container scan for backend
trivy-scan-backend:
  stage: build
  image: aquasec/trivy:latest
  dependencies:
    - build-backend
  script:
    - trivy image --exit-code 0 --severity HIGH,CRITICAL --format template --template "@contrib/gitlab.tpl" -o gl-container-scanning-report.json $CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA || true
  artifacts:
    reports:
      container_scanning: gl-container-scanning-report.json
    expire_in: 1 week
  allow_failure: true
  only:
    - main
    - develop
    - tags

# Trivy container scan for frontend
trivy-scan-frontend:
  stage: build
  image: aquasec/trivy:latest
  dependencies:
    - build-frontend
  script:
    - trivy image --exit-code 0 --severity HIGH,CRITICAL --format template --template "@contrib/gitlab.tpl" -o gl-container-scanning-report.json $CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA || true
  artifacts:
    reports:
      container_scanning: gl-container-scanning-report.json
    expire_in: 1 week
  allow_failure: true
  only:
    - main
    - develop
    - tags

# Deploy to staging
deploy-staging:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client curl
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan -H $STAGING_SSH_HOST >> ~/.ssh/known_hosts
  script:
    - |
      ssh $STAGING_SSH_USER@$STAGING_SSH_HOST << 'EOF'
        set -e
        cd $STAGING_DEPLOY_PATH
        git pull origin main
        docker-compose -f infra/docker/docker-compose.staging.yml pull
        docker-compose -f infra/docker/docker-compose.staging.yml up -d --no-deps --build
        docker-compose -f infra/docker/docker-compose.staging.yml ps
      EOF
    - |
      echo "Waiting for health check..."
      max_attempts=30
      attempt=0
      while [ $attempt -lt $max_attempts ]; do
        if curl -f $STAGING_URL/health; then
          echo "Health check passed!"
          exit 0
        fi
        attempt=$((attempt + 1))
        echo "Attempt $attempt/$max_attempts failed, retrying in 5 seconds..."
        sleep 5
      done
      echo "Health check failed after $max_attempts attempts"
      exit 1
    - |
      chmod +x scripts/smoke-tests.sh
      ./scripts/smoke-tests.sh $STAGING_URL
  environment:
    name: staging
    url: $STAGING_URL
  only:
    - main
  when: on_success

# Rollback staging on deployment failure
rollback-staging:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan -H $STAGING_SSH_HOST >> ~/.ssh/known_hosts
  script:
    - |
      ssh $STAGING_SSH_USER@$STAGING_SSH_HOST << 'EOF'
        set -e
        cd $STAGING_DEPLOY_PATH
        echo "Rolling back to previous version..."
        docker-compose -f infra/docker/docker-compose.staging.yml down
        docker-compose -f infra/docker/docker-compose.staging.yml up -d
        echo "Rollback complete"
      EOF
  only:
    - main
  when: on_failure
  needs:
    - deploy-staging

# Deploy to production
deploy-production:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client curl
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan -H $PRODUCTION_SSH_HOST >> ~/.ssh/known_hosts
  script:
    - |
      if [[ "$CI_COMMIT_TAG" =~ ^v ]]; then
        VERSION=${CI_COMMIT_TAG#v}
      else
        VERSION=$(date +%Y%m%d-%H%M%S)
      fi
      echo "Deploying version: $VERSION"
    - |
      ssh $PRODUCTION_SSH_USER@$PRODUCTION_SSH_HOST << EOF
        set -e
        cd $PRODUCTION_DEPLOY_PATH
        export VERSION=$VERSION
        git pull origin main
        docker-compose -f infra/docker/docker-compose.prod.yml pull
        docker-compose -f infra/docker/docker-compose.prod.yml up -d --no-deps --build
        docker-compose -f infra/docker/docker-compose.prod.yml ps
      EOF
    - |
      echo "Waiting for health check..."
      max_attempts=30
      attempt=0
      while [ $attempt -lt $max_attempts ]; do
        if curl -f $PRODUCTION_URL/health; then
          echo "Health check passed!"
          exit 0
        fi
        attempt=$((attempt + 1))
        echo "Attempt $attempt/$max_attempts failed, retrying in 5 seconds..."
        sleep 5
      done
      echo "Health check failed after $max_attempts attempts"
      exit 1
    - |
      chmod +x scripts/smoke-tests.sh
      ./scripts/smoke-tests.sh $PRODUCTION_URL
  environment:
    name: production
    url: $PRODUCTION_URL
  only:
    - tags
  when: manual

# Rollback production on deployment failure
rollback-production:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan -H $PRODUCTION_SSH_HOST >> ~/.ssh/known_hosts
  script:
    - |
      ssh $PRODUCTION_SSH_USER@$PRODUCTION_SSH_HOST << 'EOF'
        set -e
        cd $PRODUCTION_DEPLOY_PATH
        echo "Rolling back to previous version..."
        docker-compose -f infra/docker/docker-compose.prod.yml down
        docker-compose -f infra/docker/docker-compose.prod.yml up -d
        echo "Rollback complete"
      EOF
  only:
    - tags
  when: on_failure
  needs:
    - deploy-production
